<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Realtime Cooking Mama</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: "Inter", sans-serif;
      }
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      @keyframes popIn {
        0% {
          opacity: 0;
          transform: translateY(10px);
        }
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .msg-bubble {
        animation: popIn 0.25s ease-out forwards;
      }
      .fridge-item-card {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        padding: 0.6rem 0.95rem;
        border-radius: 9999px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.15);
        color: #fff;
        font-size: 0.8rem;
        min-width: 140px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(10px);
      }
      .fridge-item-card .item-name {
        font-weight: 600;
        text-transform: capitalize;
      }
      .fridge-item-card .item-quantity {
        font-size: 0.7rem;
        opacity: 0.8;
        margin-left: auto;
      }
      .fridge-item-card .remove-item {
        background: transparent;
        border: 0;
        color: rgba(255, 255, 255, 0.7);
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 9999px;
        font-size: 0.7rem;
        cursor: pointer;
        transition: background 0.2s, color 0.2s;
      }
      .fridge-item-card .remove-item:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #fecaca;
      }
      .listening-indicator {
        width: 36px;
        height: 36px;
        border-radius: 9999px;
        background: rgba(249, 115, 22, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(249, 115, 22, 0.3);
      }
      .listening-icon {
        color: #f97316;
        font-size: 16px;
        animation: pulseIcon 1.5s ease-in-out infinite;
      }
      @keyframes pulseIcon {
        0% {
          transform: scale(0.9);
          opacity: 0.7;
        }
        50% {
          transform: scale(1.05);
          opacity: 1;
        }
        100% {
          transform: scale(0.9);
          opacity: 0.7;
        }
      }
      .recipe-recommendation-card {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        padding: 0.85rem 1rem;
        border-radius: 1.25rem;
        border: 1px solid #ffe0c2;
        background: linear-gradient(145deg, #fff8f1, #ffffff);
        box-shadow: 0 20px 35px rgba(249, 115, 22, 0.08);
        min-width: 180px;
      }
      .recipe-recommendation-name {
        font-weight: 600;
        color: #ea580c;
      }
    </style>
  </head>
  <body class="bg-gray-100 h-screen flex flex-col md:flex-row overflow-hidden">
    <div
      class="relative w-full h-[55%] md:h-full md:w-[60%] bg-black shadow-lg shrink-0 flex flex-col overflow-hidden"
    >
      <video
        id="localVideo"
        class="w-full h-full object-cover"
        autoplay
        playsinline
        muted
      ></video>
      <video
        id="remoteVideo"
        autoplay
        playsinline
        class="absolute inset-0 opacity-0 pointer-events-none"
      ></video>

      <div
        class="absolute top-4 left-4 bg-black/60 backdrop-blur-md text-white px-3 py-1.5 rounded-full text-xs font-medium flex items-center border border-white/10 z-20"
      >
        <span
          id="status_indicator"
          class="w-2 h-2 rounded-full bg-red-500 mr-2 shadow-[0_0_12px_rgba(248,113,113,0.5)]"
        ></span>
        <span id="status_badge_text">Disconnected</span>
      </div>

      <div class="absolute top-4 right-4 z-20 max-w-xs">
        <div
          class="bg-black/60 backdrop-blur-md text-white px-4 py-3 rounded-2xl border border-white/10 shadow-lg space-y-1"
        >
          <p
            class="text-[10px] uppercase tracking-[0.2em] text-gray-300 font-semibold"
          >
            Detection
          </p>
          <p id="detection_description" class="text-xs text-gray-200">
            Waiting for detections
          </p>
          <div
            id="detection"
            class="text-[11px] text-white/80 font-medium max-h-28 overflow-y-auto no-scrollbar"
          >
            Detections: []
          </div>
        </div>
      </div>

      <div
        class="absolute bottom-0 left-0 w-full p-4 pb-6 bg-gradient-to-t from-black/90 via-black/70 to-transparent z-20 flex flex-col gap-3"
      >
        <div class="flex items-center justify-between">
          <div
            class="text-white/80 text-xs uppercase tracking-[0.35em] font-semibold"
          >
            Ingredients
          </div>
          <button
            id="recommend_recipe"
            class="text-[11px] bg-white/15 hover:bg-white/25 text-white px-4 py-2 rounded-full border border-white/20 flex items-center gap-2 transition"
          >
            <i class="fas fa-magic text-orange-300"></i> Recommend Recipe
          </button>
        </div>
        <div
          id="fridge_items"
          class="flex flex-wrap gap-2 max-h-[140px] overflow-y-auto no-scrollbar pr-1"
        >
          <p class="text-white/70 text-xs italic">
            No ingredients detected yet.
          </p>
        </div>
      </div>
    </div>

    <div
      class="flex-1 bg-[#fdfdfd] md:border-l border-gray-200 flex flex-col shadow-[0_-10px_30px_rgba(0,0,0,0.05)]"
    >
      <div
        class="px-4 py-3 border-b border-gray-100 bg-white flex items-center justify-between"
      >
        <h2 class="font-semibold text-gray-800 text-sm flex items-center gap-2">
          <i class="fas fa-comments text-orange-500"></i>
          Cooking Assistant
        </h2>
        <div class="flex gap-2 text-xs">
          <button
            id="select_crab"
            class="px-3 py-1.5 rounded-full border border-gray-200 text-gray-600 hover:bg-gray-100 transition"
          >
            ü¶Ä Crab Mode
          </button>
          <button
            id="select_wrong"
            class="px-3 py-1.5 rounded-full border border-red-200 text-red-500 hover:bg-red-50 transition"
          >
            ‚ùå Error Mode
          </button>
        </div>
      </div>

      <div
        id="connection_status"
        class="mx-4 mt-4 px-4 py-3 rounded-2xl border text-sm font-medium shadow-sm"
        style="display: none"
      >
        <strong class="text-gray-600 mr-1">Connection Status:</strong>
        <span id="status_text" class="text-gray-800">Not connected</span>
      </div>

      <div
        id="error_message"
        class="mx-4 mt-3 px-4 py-3 rounded-2xl border border-red-200 bg-red-50 text-red-700 text-sm shadow-sm"
        style="display: none"
      >
        <strong class="font-semibold mr-1">Error:</strong>
        <span id="error_text"></span>
      </div>

      <div class="flex-1 flex flex-col overflow-hidden">
        <div id="recipe_progress_section" class="p-4 hidden">
          <div
            class="bg-white rounded-3xl border border-orange-100 shadow-sm p-4 space-y-3"
          >
            <div class="flex items-center justify-between">
              <span
                class="text-[10px] tracking-[0.3em] uppercase font-semibold text-orange-500"
                >Recipe Progress</span
              >
              <span id="recipe_selected" class="text-xs text-gray-500"
                >Recipe Selected: -</span
              >
            </div>
            <p id="recipe_step" class="text-gray-800 text-sm font-medium">
              Step 0: Waiting for ingredients...
            </p>
            <div class="flex flex-col md:flex-row gap-2">
              <button
                id="recipe_prev"
                class="flex-1 bg-gray-50 border border-gray-200 text-gray-600 py-2 rounded-xl text-xs font-bold hover:bg-gray-100 transition"
              >
                Previous
              </button>
              <button
                id="recipe_next"
                class="flex-1 bg-orange-500 text-white py-2 rounded-xl text-xs font-bold shadow hover:bg-orange-600 transition"
              >
                Next Step
              </button>
              <button
                id="recipe_done"
                class="flex-1 bg-green-500 text-white py-2 rounded-xl text-xs font-bold shadow hover:bg-green-600 transition"
              >
                Mark Complete
              </button>
            </div>
          </div>
        </div>

        <div id="recipe_section" class="px-4 hidden">
          <div class="flex items-center justify-between text-xs text-gray-500">
            <span class="uppercase tracking-[0.3em] font-semibold text-gray-400"
              >Recipes</span
            >
            <span class="text-[11px] text-gray-400"
              >Auto-updates as Yoribo reasons</span
            >
          </div>
          <div
            id="recipe_recommend"
            class="flex flex-wrap gap-3 mt-3 pb-2"
          ></div>
        </div>

        <div class="px-4 pt-2">
          <div
            id="listening_indicator"
            class="hidden listening-indicator shadow-inner"
            title="Listening to user"
          >
            <i class="fas fa-ear-listen listening-icon"></i>
          </div>
        </div>

        <div
          id="chat_scroller"
          class="flex-1 overflow-y-auto px-4 py-4 no-scrollbar bg-gray-50"
        >
          <div id="chat_history" class="space-y-4"></div>
        </div>

        <!-- Removed remote audio stats / recipe completion cards to avoid blocking chat -->
      </div>

      <div class="p-4 border-t border-gray-100 bg-white">
        <button
          id="start"
          class="w-full bg-gradient-to-r from-orange-500 to-red-500 text-white py-3 rounded-2xl font-bold text-base shadow-lg shadow-orange-100 active:scale-[0.98] transition-transform flex items-center justify-center gap-2"
        >
          <i class="fas fa-microphone"></i> Start Cooking Session
        </button>

        <div id="input_area" class="hidden mt-3 flex items-center gap-2">
          <div
            class="flex-1 bg-gray-100 rounded-full px-4 py-2.5 flex items-center border border-transparent focus-within:border-orange-300 focus-within:bg-white transition-all"
          >
            <input
              type="text"
              id="textInput"
              placeholder="Type a manual instruction..."
              class="bg-transparent w-full outline-none text-sm text-gray-800 placeholder-gray-400"
            />
          </div>
          <button
            id="sendMessage"
            class="bg-orange-500 text-white w-11 h-11 rounded-full flex items-center justify-center shadow-md active:scale-95 transition hover:bg-orange-600"
          >
            <i class="fas fa-paper-plane text-sm"></i>
          </button>
          <button
            id="closeConnection"
            class="bg-gray-100 text-gray-500 w-11 h-11 rounded-full flex items-center justify-center active:scale-95 transition hover:bg-gray-200"
          >
            <i class="fas fa-power-off text-sm"></i>
          </button>
        </div>
      </div>
    </div>

    <script>
      let localConnection;
      let remoteStream = new MediaStream();
      let signalingSocket;
      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const startButton = document.getElementById("start");
      const closeConnectionButton = document.getElementById("closeConnection");
      const chatHistoryElement = document.getElementById("chat_history");
      const chatScroller = document.getElementById("chat_scroller");
      const remoteAudioStatsEl = document.getElementById("remote_audio_stats");
      const listeningIndicator = document.getElementById("listening_indicator");
      const recipeProgressSection = document.getElementById(
        "recipe_progress_section"
      );
      const recipeSection = document.getElementById("recipe_section");
      let lastDetectionTime = null;
      let statsInterval = null;
      let isSessionActive = false;
      let assistantTranscriptBuffer = "";
      let userTranscriptBuffer = "";
      let activeAssistantBubble = null;
      let activeUserBubble = null;
      let hasRecipeRecommendations = false;
      let recipeSelected = false;
      let activeUserBubbleTimestamp = null;
      let messageOrderCounter = 0;
      let userOrderOffset = 0;

      function logRemoteAudioStatus(label) {
        if (!remoteVideo.srcObject) {
          console.log(`[RemoteAudio][${label}] no srcObject`);
          return;
        }
        const audioTracks = remoteVideo.srcObject
          .getAudioTracks()
          .map((track) => ({
            id: track.id,
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState,
            label: track.label,
          }));
        console.log(
          `[RemoteAudio][${label}] paused=${remoteVideo.paused} muted=${
            remoteVideo.muted
          } volume=${remoteVideo.volume} tracks=${JSON.stringify(audioTracks)}`
        );
      }

      remoteVideo.addEventListener("playing", () =>
        logRemoteAudioStatus("playing")
      );
      remoteVideo.addEventListener("pause", () =>
        logRemoteAudioStatus("pause")
      );

      async function collectAudioStats() {
        if (!localConnection) {
          return;
        }
        try {
          const stats = await localConnection.getStats(null);
          const lines = [];
          stats.forEach((report) => {
            if (
              report.type === "inbound-rtp" &&
              (report.kind === "audio" || report.mediaType === "audio")
            ) {
              const jitterValue =
                typeof report.jitter === "number"
                  ? report.jitter.toFixed(5)
                  : report.jitter;
              lines.push(
                `inbound audio: packets=${report.packetsReceived} lost=${report.packetsLost} jitter=${jitterValue} bytes=${report.bytesReceived}`
              );
            }
            if (report.type === "track" && report.kind === "audio") {
              lines.push(
                `track audio: framesDecoded=${report.framesDecoded} totalEnergy=${report.totalAudioEnergy}`
              );
            }
          });
          if (lines.length === 0) {
            lines.push("no inbound audio stats yet");
          }
          if (remoteAudioStatsEl) {
            remoteAudioStatsEl.innerText = lines.join("\n");
          }
        } catch (err) {
          console.error("collectAudioStats error", err);
        }
      }

      function startStatsMonitor() {
        if (statsInterval) {
          return;
        }
        statsInterval = setInterval(collectAudioStats, 2000);
      }

      function stopStatsMonitor() {
        if (statsInterval) {
          clearInterval(statsInterval);
          statsInterval = null;
          if (remoteAudioStatsEl) {
            remoteAudioStatsEl.innerText = "(stopped)";
          }
        }
      }

      function updateSessionButton() {
        if (!startButton) {
          return;
        }
        if (isSessionActive) {
          startButton.innerHTML = '<i class="fas fa-power-off"></i> Close';
        } else {
          startButton.innerHTML =
            '<i class="fas fa-microphone"></i> Start Cooking Session';
        }
      }
      updateSessionButton();

      function setSessionActive(active) {
        isSessionActive = active;
        updateSessionButton();
      }

      function closeActiveSession() {
        if (localConnection) {
          localConnection.close();
          localConnection = null;
          console.log("P2P Connection closed.");
        }
        if (signalingSocket) {
          signalingSocket.close();
          signalingSocket = null;
          console.log("WebSocket connection closed.");
        }
        stopStatsMonitor();
        setSessionActive(false);
        discardUserBubble();
        recipeSelected = false;
        hasRecipeRecommendations = false;
        messageOrderCounter = 0;
        userOrderOffset = 0;
        updateRecipeRecommendationVisibility();
        updateRecipeProgressVisibility();
      }

      function scrollChatToBottom() {
        if (chatScroller) {
          chatScroller.scrollTop = chatScroller.scrollHeight;
        }
      }

      function updateRecipeProgressVisibility() {
        if (!recipeProgressSection) {
          return;
        }
        if (recipeSelected) {
          recipeProgressSection.classList.remove("hidden");
        } else {
          recipeProgressSection.classList.add("hidden");
        }
      }

      function updateRecipeRecommendationVisibility() {
        if (!recipeSection) {
          return;
        }
        if (hasRecipeRecommendations) {
          recipeSection.classList.remove("hidden");
        } else {
          recipeSection.classList.add("hidden");
        }
      }

      updateRecipeRecommendationVisibility();
      updateRecipeProgressVisibility();

      function allocateAssistantOrder() {
        messageOrderCounter += 1;
        userOrderOffset = 0;
        return messageOrderCounter;
      }

      function allocateUserOrder() {
        userOrderOffset += 0.01;
        return messageOrderCounter + userOrderOffset;
      }

      function insertBubbleOrdered(wrapper, order) {
        if (!chatHistoryElement) {
          return;
        }
        wrapper.dataset.order = order.toString();
        const children = Array.from(chatHistoryElement.children);
        const nextSibling = children.find((child) => {
          const childOrder = Number(child.dataset.order || 0);
          return childOrder > order;
        });
        if (nextSibling) {
          chatHistoryElement.insertBefore(wrapper, nextSibling);
        } else {
          chatHistoryElement.appendChild(wrapper);
        }
        scrollChatToBottom();
      }

      function createChatBubble(role, order) {
        if (!chatHistoryElement) {
          return null;
        }
        const wrapper = document.createElement("div");
        wrapper.className =
          role === "assistant"
            ? "flex justify-end msg-bubble"
            : "flex justify-start msg-bubble";
        const bubble = document.createElement("div");
        if (role === "assistant") {
          bubble.className =
            "bg-gradient-to-r from-orange-500 to-red-500 text-white px-4 py-3 rounded-2xl rounded-tr-none max-w-[90%] text-sm shadow w-full";
        } else {
          bubble.className =
            "bg-white text-gray-800 px-4 py-3 rounded-2xl rounded-tl-none max-w-[90%] text-sm shadow border border-gray-200 w-full";
        }
        const label = document.createElement("p");
        label.className =
          role === "assistant"
            ? "text-[11px] uppercase text-white/70 tracking-[0.3em] mb-1"
            : "text-[11px] uppercase text-gray-400 tracking-[0.3em] mb-1";
        label.innerText = role === "assistant" ? "Assistant" : "User";
        const textEl = document.createElement("div");
        textEl.className =
          role === "assistant" ? "font-semibold" : "font-medium text-gray-800";
        bubble.appendChild(label);
        bubble.appendChild(textEl);
        wrapper.appendChild(bubble);
        insertBubbleOrdered(wrapper, order ?? allocateAssistantOrder());
        return { wrapper, textEl };
      }

      function setChatBubbleText(bubble, role, text) {
        if (!bubble) {
          return;
        }
        const prefix = role === "assistant" ? "GPT" : "User";
        bubble.textEl.innerText = `${prefix}: ${text}`;
        scrollChatToBottom();
      }

      function finalizeAssistantBubble(text) {
        const content = (text || "").trim();
        if (!content) {
          return;
        }
        const bubble = createChatBubble("assistant", allocateAssistantOrder());
        setChatBubbleText(bubble, "assistant", content);
      }

      function ensureUserBubble() {
        if (!activeUserBubble) {
          const order =
            typeof activeUserBubbleTimestamp === "number"
              ? activeUserBubbleTimestamp
              : allocateUserOrder();
          activeUserBubble = createChatBubble("user", order);
          activeUserBubbleTimestamp = order;
          userTranscriptBuffer = "";
        }
        return activeUserBubble;
      }

      function setListeningIndicator(visible) {
        if (!listeningIndicator) {
          return;
        }
        listeningIndicator.classList.toggle("hidden", !visible);
      }

      function startUserSpeech() {
        const order = allocateUserOrder();
        activeUserBubbleTimestamp = order;
        activeUserBubble = createChatBubble("user", order);
        if (activeUserBubble) {
          activeUserBubble.textEl.innerHTML =
            '<span class="inline-flex items-center justify-center text-orange-500"><i class="fas fa-ear-listen listening-icon"></i></span>';
          activeUserBubble.wrapper.dataset.listening = "true";
        }
        userTranscriptBuffer = "";
        setListeningIndicator(true);
      }

      function discardUserBubble() {
        if (activeUserBubble && activeUserBubble.wrapper.parentNode) {
          activeUserBubble.wrapper.parentNode.removeChild(
            activeUserBubble.wrapper
          );
        }
        activeUserBubble = null;
        userTranscriptBuffer = "";
        activeUserBubbleTimestamp = null;
        setListeningIndicator(false);
      }

      function updateUserMessage(text, finalize = false) {
        const bubble = ensureUserBubble();
        const trimmed = (text || "").trim();
        if (bubble.wrapper.dataset.listening === "true" && trimmed.length > 0) {
          bubble.wrapper.dataset.listening = "false";
        }
        if (trimmed.length > 0) {
          setChatBubbleText(bubble, "user", trimmed);
        }
        if (finalize) {
          activeUserBubble = null;
          userTranscriptBuffer = "";
          activeUserBubbleTimestamp = null;
          setListeningIndicator(false);
        }
      }

      function updateStatusBadge(message, isError = false) {
        const badgeText = document.getElementById("status_badge_text");
        const indicator = document.getElementById("status_indicator");
        if (badgeText) {
          badgeText.innerText = message;
        }
        if (indicator) {
          indicator.classList.remove(
            "bg-red-500",
            "bg-green-500",
            "bg-yellow-400",
            "animate-pulse"
          );
          if (isError) {
            indicator.classList.add("bg-red-500");
          } else if (
            /ready|connected|initialized|complete|done|voice agent/i.test(
              message
            )
          ) {
            indicator.classList.add("bg-green-500");
          } else {
            indicator.classList.add("bg-yellow-400", "animate-pulse");
          }
        }
      }

      // Connection status display function
      function showConnectionStatus(message, isError = false) {
        const statusDiv = document.getElementById("connection_status");
        const statusText = document.getElementById("status_text");
        if (statusDiv) {
          statusDiv.style.display = "block";
          statusDiv.style.backgroundColor = isError ? "#ffebee" : "#e8f5e9";
          statusDiv.style.color = isError ? "#c62828" : "#2e7d32";
        }
        if (statusText) {
          statusText.innerText = message;
        }
        updateStatusBadge(message, isError);
      }

      // Error message display function
      function showError(message) {
        console.error("Error:", message);
        const errorDiv = document.getElementById("error_message");
        const errorText = document.getElementById("error_text");
        errorDiv.style.display = "block";
        errorText.innerText = message;
        alert("Error: " + message);
      }

      // Hide error message function
      function hideError() {
        document.getElementById("error_message").style.display = "none";
      }

      async function startCookingSession() {
        try {
          hideError();
          showConnectionStatus("WebSocket connecting...");

          // Close existing connections if any
          if (localConnection) {
            localConnection.close();
            localConnection = null;
          }
          if (signalingSocket) {
            signalingSocket.close();
          }

          // Create a new WebSocket connection
          let wsUrl = "wss://yori.jdn.kr/signal";
          if (window.location.hostname === "localhost") {
            wsUrl = "ws://localhost:5050/signal";
          }
          signalingSocket = new WebSocket(wsUrl);
          setSessionActive(true);

          signalingSocket.onerror = (error) => {
            console.error("WebSocket error:", error);
            showConnectionStatus("WebSocket connection failed", true);
            showError(
              "Unable to reach the server. Please ensure it is running."
            );
            closeActiveSession();
          };

          signalingSocket.onclose = () => {
            console.log("WebSocket closed");
            const wasActive = isSessionActive;
            showConnectionStatus("Connection closed", wasActive);
            stopStatsMonitor();
            setSessionActive(false);
          };

          signalingSocket.onopen = () => {
            console.log("WebSocket connected");
            showConnectionStatus("WebSocket connected");
          };

          // Set up WebSocket message handler
          signalingSocket.onmessage = async (message) => {
            try {
              const data = JSON.parse(message.data);
              console.log(data);

              if (data.type === "system") {
                if (data.event === "api_key") {
                  showConnectionStatus("Waiting for API key input...");
                  const apiKey = prompt("Please enter your OpenAI API Key:");
                  if (apiKey) {
                    showConnectionStatus("Sending API key...");
                    signalingSocket.send(JSON.stringify({ api_key: apiKey }));
                  } else {
                    showConnectionStatus("API key not provided", true);
                  }
                } else if (data.event === "error") {
                  showConnectionStatus("Error occurred", true);
                  showError(data.data);
                } else if (data.event === "assistant_initialized") {
                  showConnectionStatus("Voice agent initialized ‚úì");
                  console.log("Assistant initialized successfully");
                } else if (data.event === "assistant_error") {
                  showConnectionStatus(
                    "Voice agent initialization failed",
                    true
                  );
                  showError("Voice agent initialization failed: " + data.data);
                } else if (data.event === "connected") {
                  showConnectionStatus("Server connected");
                } else if (data.event === "yoribo_ready") {
                  showConnectionStatus("Yoribo ready ‚úì");
                }
              }

              if (data.type === "answer") {
                // Process answer from server
                const remoteDescription = new RTCSessionDescription({
                  type: data.type,
                  sdp: data.sdp,
                });
                await localConnection.setRemoteDescription(remoteDescription);
              } else if (data.type === "assistant") {
                if (data.event === "message") {
                  finalizeAssistantBubble(data.data || "");
                } else if (data.event === "recipe_recommend") {
                  drawRecipeRecommendationList(data.data);
                }
              } else if (data.type === "user") {
                if (data.event === "transcript") {
                  const chunk = (data.data || "").trim();
                  if (!activeUserBubble) {
                    startUserSpeech();
                  }
                  if (chunk.length > 0) {
                    if (
                      userTranscriptBuffer.length > 0 &&
                      chunk.startsWith(userTranscriptBuffer)
                    ) {
                      userTranscriptBuffer = chunk;
                    } else {
                      userTranscriptBuffer =
                        `${userTranscriptBuffer} ${chunk}`.trim();
                    }
                    updateUserMessage(userTranscriptBuffer);
                  }
                } else if (data.event === "speech_started") {
                  if (activeUserBubble) {
                    const leftover = userTranscriptBuffer.trim();
                    if (leftover.length > 0) {
                      updateUserMessage(leftover, true);
                    } else {
                      discardUserBubble();
                    }
                  }
                  startUserSpeech();
                } else if (data.event === "speech_stopped") {
                  const finalText = userTranscriptBuffer.trim();
                  if (finalText.length > 0) {
                    updateUserMessage(finalText, true);
                  } else {
                    discardUserBubble();
                  }
                } else if (data.event === "object_detection") {
                  if (lastDetectionTime) {
                    const timeDiff = Date.now() - lastDetectionTime;
                    document.getElementById(
                      "detection_description"
                    ).innerText = `Detections (${timeDiff}ms)`;
                  }
                  lastDetectionTime = Date.now();
                  document.getElementById(
                    "detection"
                  ).innerText = `Detections: ${JSON.stringify(data.data)}`;
                } else if (data.event === "fridge_items") {
                  drawFridgeItems(data.data);
                } else if (data.event === "recipe_selected") {
                  recipeSelected = true;
                  updateRecipeProgressVisibility();
                  document.getElementById(
                    "recipe_selected"
                  ).innerText = `Recipe Selected: ${data.data.name}`;
                } else if (data.event === "recipe_step") {
                  recipeSelected = true;
                  updateRecipeProgressVisibility();
                  document.getElementById(
                    "recipe_step"
                  ).innerText = `Step ${data.data.order}: ${data.data.description}`;
                } else if (data.event === "recipe_completed") {
                  recipeSelected = false;
                  hasRecipeRecommendations = false;
                  updateRecipeRecommendationVisibility();
                  updateRecipeProgressVisibility();
                  document.getElementById(
                    "recipe_done"
                  ).innerText = `Recipe Done! (${JSON.stringify(data.data)})`;
                }
              } else if (data.candidate) {
                // Process ICE candidate from server
                const candidate = new RTCIceCandidate({
                  candidate: data.candidate,
                  sdpMid: data.sdpMid,
                  sdpMLineIndex: data.sdpMLineIndex,
                });
                await localConnection.addIceCandidate(candidate);
              }
            } catch (error) {
              console.error("Error handling signaling message:", error);
            }
          };

          // Get user's video and audio stream
          const devices = await navigator.mediaDevices.enumerateDevices();
          const hasVideo = devices.some(
            (device) => device.kind === "videoinput"
          );

          const localStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: hasVideo ? { facingMode: { ideal: "environment" } } : false,
          });
          localVideo.srcObject = localStream;

          // Set up RTCPeerConnection
          localConnection = new RTCPeerConnection();

          // Add local stream tracks to peer connection
          localStream.getTracks().forEach((track) => {
            localConnection.addTrack(track, localStream);
          });

          // Handle ICE candidates
          localConnection.onicecandidate = ({ candidate }) => {
            if (candidate) {
              signalingSocket.send(
                JSON.stringify({
                  type: "candidate",
                  candidate: candidate.candidate,
                  sdpMid: candidate.sdpMid,
                  sdpMLineIndex: candidate.sdpMLineIndex,
                })
              );
            }
          };

          localConnection.onconnectionstatechange = (event) => {
            const state = event.target.connectionState;
            console.log("P2P Connection state:", state);

            if (state === "connected") {
              showConnectionStatus("P2P connected ‚úì");
              startStatsMonitor();
            } else if (state === "connecting") {
              showConnectionStatus("P2P connecting...");
            } else if (state === "failed") {
              showConnectionStatus("P2P connection failed", true);
              showError(
                "P2P connection failed. Please check network settings."
              );
              stopStatsMonitor();
            } else if (state === "disconnected") {
              showConnectionStatus("P2P disconnected", true);
              stopStatsMonitor();
            } else if (state === "closed") {
              showConnectionStatus("P2P connection closed");
              stopStatsMonitor();
            }
          };

          localConnection.onnegotiationneeded = async () => {
            console.log("Negotiation needed");
          };

          localConnection.ontrack = (event) => {
            console.log("Track received:", event.track.kind);
            if (!remoteStream.getTracks().includes(event.track)) {
              remoteStream.addTrack(event.track);
            }
            remoteVideo.srcObject = remoteStream;
            remoteVideo.muted = false;
            remoteVideo.volume = 1;
            remoteVideo
              .play()
              .then(() => logRemoteAudioStatus("play promise resolved"))
              .catch((err) => console.error("remoteVideo play() failed:", err));
            logRemoteAudioStatus("ontrack");
            startStatsMonitor();
          };

          // Create and send offer
          const offer = await localConnection.createOffer();
          await localConnection.setLocalDescription(offer);

          const offerData = {
            type: offer.type,
            sdp: offer.sdp,
          };
          signalingSocket.send(JSON.stringify(offerData));
        } catch (error) {
          console.error(
            "Error during offer creation or media stream acquisition:",
            error
          );
          closeActiveSession();
        }
      }

      if (startButton) {
        startButton.onclick = async () => {
          if (isSessionActive) {
            closeActiveSession();
          } else {
            await startCookingSession();
          }
        };
      }

      if (closeConnectionButton) {
        closeConnectionButton.onclick = () => {
          closeActiveSession();
        };
      }

      document.getElementById("sendMessage").onclick = () => {
        const textInput = document.getElementById("textInput").value;
        if (textInput.trim() !== "") {
          const messageData = {
            type: "message",
            data: textInput,
          };
          signalingSocket.send(JSON.stringify(messageData));
          document.getElementById("textInput").value = ""; // Clear the input field
        }
      };

      document.getElementById("recommend_recipe").onclick = () => {
        signalingSocket.send(JSON.stringify({ type: "recommend_recipe" }));
      };
      document.getElementById("select_crab").onclick = () => {
        selectRecipe(1);
      };
      document.getElementById("select_wrong").onclick = () => {
        selectRecipe(2);
      };
      document.getElementById("recipe_next").onclick = () => {
        signalingSocket.send(
          JSON.stringify({ type: "recipe_cook", data: "go_next_step" })
        );
      };
      document.getElementById("recipe_prev").onclick = () => {
        signalingSocket.send(
          JSON.stringify({ type: "recipe_cook", data: "go_previous_step" })
        );
      };
      document.getElementById("recipe_done").onclick = () => {
        signalingSocket.send(
          JSON.stringify({ type: "recipe_cook", data: "done" })
        );
      };

      function drawFridgeItems(items) {
        const fridgeItems = document.getElementById("fridge_items");
        fridgeItems.innerHTML = "";
        for (const item of items) {
          drawFridgeItem(item.id, item.name, item.quantity);
        }
      }

      function drawFridgeItem(itemId, itemName, count) {
        const itemCardId = `fridge_item_${itemId}`;
        const fridgeItems = document.getElementById("fridge_items");
        let itemCard = document.getElementById(itemCardId);
        if (!itemCard) {
          itemCard = document.createElement("div");
          itemCard.className = "fridge-item-card";
          itemCard.id = itemCardId;

          const itemNameElement = document.createElement("span");
          itemNameElement.className = "item-name";
          const itemQuantityElement = document.createElement("span");
          itemQuantityElement.className = "item-quantity";
          const removeItemButton = document.createElement("button");
          removeItemButton.className = "remove-item";
          fridgeItems.appendChild(itemCard);
          itemCard.appendChild(itemNameElement);
          itemCard.appendChild(itemQuantityElement);
          itemCard.appendChild(removeItemButton);
        }
        itemCard.querySelector(".item-name").innerText = itemName;
        itemCard.querySelector(".item-quantity").innerText = count.toString();
        itemCard.querySelector(".remove-item").innerText = "x";
        itemCard.querySelector(".remove-item").onclick = () => {
          signalingSocket.send(
            JSON.stringify({
              type: "fridge",
              data: `remove_${itemId}`,
            })
          );
        };
      }

      function drawRecipeRecommendationList(recommendations) {
        const recipeRecommendation =
          document.getElementById("recipe_recommend");
        if (!recipeRecommendation) {
          return;
        }
        recipeRecommendation.innerHTML = "";
        hasRecipeRecommendations =
          !!recommendations && recommendations.length > 0;
        updateRecipeRecommendationVisibility();
        if (!hasRecipeRecommendations) {
          return;
        }
        for (const recommendation of recommendations) {
          drawRecipeRecommendation(recommendation);
        }
      }

      function drawRecipeRecommendation(recommendation) {
        const recipeName = recommendation.name;
        const recipeRecommendation =
          document.getElementById("recipe_recommend");
        const recipeCard = document.createElement("div");
        recipeCard.className = "recipe-recommendation-card";
        recipeCard.id = `recipe_recommendation_${recipeName}`;
        recipeRecommendation.appendChild(recipeCard);
        const recipeNameElement = document.createElement("span");
        recipeNameElement.className = "recipe-recommendation-name";
        recipeNameElement.innerText = `${recommendation.name} - Time: ${recommendation.time} min`;
        recipeCard.appendChild(recipeNameElement);
      }

      function selectRecipe(recipeId) {
        signalingSocket.send(
          JSON.stringify({
            type: "select_recipe",
            data: recipeId,
          })
        );
      }
    </script>
  </body>
</html>
